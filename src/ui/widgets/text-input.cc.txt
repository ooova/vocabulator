#include "text-input.h"

namespace ui::widgets {

TextInput::TextInput(RVector2 position, RVector2 size, RFont&& font,
                     RColor text_color, RColor background_color, RColor cursor_color)
    : RRectangle(position.GetX(), position.GetY(), size.GetX(), size.GetY()),
      font_(std::move(font)),
      text_color_(text_color),
      background_color_(background_color),
      cursor_color_(cursor_color),
      text_offset_x_(position.GetX()) {
}

void TextInput::update(float dt) {
    // Ввод символов
    int codepoint;
    while ((codepoint = GetCharPressed()) != 0) {
        std::string char_str = codepoint_to_utf8(codepoint);
        text_.insert(cursor_pos_, char_str);
        cursor_pos_ += char_str.size();
    }

    // Обработка клавиш управления
    if (IsKeyPressed(KEY_BACKSPACE) && cursor_pos_ > 0) {
        size_t prev_pos = prev_char_pos(cursor_pos_);
        text_.erase(prev_pos, cursor_pos_ - prev_pos);
        cursor_pos_ = prev_pos;
    }
    if (IsKeyPressed(KEY_DELETE) && cursor_pos_ < text_.size()) {
        size_t next_pos = next_char_pos(cursor_pos_);
        text_.erase(cursor_pos_, next_pos - cursor_pos_);
    }
    if (IsKeyPressed(KEY_LEFT) && cursor_pos_ > 0) {
        cursor_pos_ = prev_char_pos(cursor_pos_);
    }
    if (IsKeyPressed(KEY_RIGHT) && cursor_pos_ < text_.size()) {
        cursor_pos_ = next_char_pos(cursor_pos_);
    }
    if (IsKeyPressed(KEY_HOME)) {
        cursor_pos_ = 0;
    }
    if (IsKeyPressed(KEY_END)) {
        cursor_pos_ = text_.size();
    }

    // Корректировка смещения текста для видимости курсора
    Vector2 cursor_vec = MeasureTextEx(font_.get(), text_.substr(0, cursor_pos_).c_str(), font_size_, spacing_);
    float cursor_x = cursor_vec.x;
    float cursor_screen_x = text_offset_x_ + cursor_x;
    if (cursor_screen_x < GetX()) {
        text_offset_x_ += GetX() - cursor_screen_x;
    } else if (cursor_screen_x > GetX() + GetWidth()) {
        text_offset_x_ -= cursor_screen_x - (GetX() + GetWidth());
    }

    // Обновление таймера мигания курсора
    cursor_timer_ += dt;
    if (cursor_timer_ >= 0.5f) {
        cursor_visible_ = !cursor_visible_;
        cursor_timer_ = 0.0f;
    }
}

void TextInput::draw() {
    // Отрисовка фона
    DrawRectangleRec(*this, background_color_.get());

    // Отрисовка текста с обрезкой
    BeginScissorMode(GetX(), GetY(), GetWidth(), GetHeight());
    DrawTextEx(font_.get(), text_.c_str(), {text_offset_x_, GetY()}, font_size_, spacing_, text_color_.get());
    EndScissorMode();

    // Отрисовка курсора, если он виден
    if (cursor_visible_) {
        Vector2 cursor_vec = MeasureTextEx(font_.get(), text_.substr(0, cursor_pos_).c_str(), font_size_, spacing_);
        float cursor_x = cursor_vec.x;
        float cursor_screen_x = text_offset_x_ + cursor_x;
        DrawLine(cursor_screen_x, GetY(), cursor_screen_x, GetY() + font_size_, cursor_color_.get());
    }
}

size_t TextInput::prev_char_pos(size_t pos) const {
    if (pos == 0) return 0;
    pos--;
    while (pos > 0 && (text_[pos] & 0xC0) == 0x80) {
        pos--;
    }
    return pos;
}

size_t TextInput::next_char_pos(size_t pos) const {
    if (pos >= text_.size()) return text_.size();
    pos++;
    while (pos < text_.size() && (text_[pos] & 0xC0) == 0x80) {
        pos++;
    }
    return pos;
}

std::string TextInput::codepoint_to_utf8(int codepoint) const {
    std::string result;
    if (codepoint <= 0x7F) {
        result += static_cast<char>(codepoint);
    } else if (codepoint <= 0x7FF) {
        result += static_cast<char>(0xC0 | (codepoint >> 6));
        result += static_cast<char>(0x80 | (codepoint & 0x3F));
    } else if (codepoint <= 0xFFFF) {
        result += static_cast<char>(0xE0 | (codepoint >> 12));
        result += static_cast<char>(0x80 | ((codepoint >> 6) & 0x3F));
        result += static_cast<char>(0x80 | (codepoint & 0x3F));
    }
    return result;
}

}  // namespace ui::widgets